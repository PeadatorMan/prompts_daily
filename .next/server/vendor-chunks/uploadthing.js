"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/uploadthing";
exports.ids = ["vendor-chunks/uploadthing"];
exports.modules = {

/***/ "(ssr)/./node_modules/uploadthing/client/index.js":
/*!**************************************************!*\
  !*** ./node_modules/uploadthing/client/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UploadAbortedError: () => (/* reexport safe */ _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadAbortedError),\n/* harmony export */   genUploader: () => (/* binding */ genUploader),\n/* harmony export */   generateClientDropzoneAccept: () => (/* reexport safe */ _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generateClientDropzoneAccept),\n/* harmony export */   generateMimeTypes: () => (/* reexport safe */ _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generateMimeTypes),\n/* harmony export */   generatePermittedFileTypes: () => (/* reexport safe */ _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generatePermittedFileTypes),\n/* harmony export */   isValidFileSize: () => (/* binding */ isValidFileSize),\n/* harmony export */   isValidFileType: () => (/* binding */ isValidFileType),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var effect_Array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! effect/Array */ \"(ssr)/./node_modules/effect/dist/esm/Array.js\");\n/* harmony import */ var effect_Function__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! effect/Function */ \"(ssr)/./node_modules/effect/dist/esm/Function.js\");\n/* harmony import */ var effect_Micro__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! effect/Micro */ \"(ssr)/./node_modules/effect/dist/esm/Micro.js\");\n/* harmony import */ var effect_Option__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! effect/Option */ \"(ssr)/./node_modules/effect/dist/esm/Option.js\");\n/* harmony import */ var _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @uploadthing/shared */ \"(ssr)/./node_modules/@uploadthing/shared/dist/index.js\");\n/* harmony import */ var std_env__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! std-env */ \"(ssr)/./node_modules/std-env/dist/index.mjs\");\n\n\n\n\n\n\n\nvar version$1 = \"6.13.3\";\nconst uploadMultipartWithProgress = (file, presigned, opts)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.gen(function*() {\n        let uploadedBytes = 0;\n        const etags = yield* effect_Micro__WEBPACK_IMPORTED_MODULE_1__.forEach(presigned.urls, (url, index)=>{\n            const offset = presigned.chunkSize * index;\n            const end = Math.min(offset + presigned.chunkSize, file.size);\n            const chunk = file.slice(offset, end);\n            return uploadPart({\n                url,\n                chunk: chunk,\n                contentDisposition: presigned.contentDisposition,\n                fileType: file.type,\n                fileName: file.name,\n                onProgress: (delta)=>{\n                    uploadedBytes += delta;\n                    const percent = uploadedBytes / file.size * 100;\n                    opts.onUploadProgress?.({\n                        file: file.name,\n                        progress: percent\n                    });\n                }\n            }).pipe(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.map((tag)=>({\n                    tag,\n                    partNumber: index + 1\n                })), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.retry({\n                while: (error)=>error instanceof _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.RetryError,\n                times: std_env__WEBPACK_IMPORTED_MODULE_2__.isTest ? 3 : 10,\n                schedule: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.exponentialDelay)()\n            }));\n        }, {\n            concurrency: \"inherit\"\n        }).pipe(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.tapError((error)=>opts.reportEventToUT(\"failure\", {\n                fileKey: presigned.key,\n                uploadId: presigned.uploadId,\n                fileName: file.name,\n                storageProviderError: String(error)\n            })));\n        // Tell the server that the upload is complete\n        yield* opts.reportEventToUT(\"multipart-complete\", {\n            uploadId: presigned.uploadId,\n            fileKey: presigned.key,\n            etags\n        });\n    });\nconst uploadPart = (opts)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.async((resume)=>{\n        const xhr = new XMLHttpRequest();\n        xhr.open(\"PUT\", opts.url, true);\n        xhr.setRequestHeader(\"Content-Type\", opts.fileType);\n        xhr.setRequestHeader(\"Content-Disposition\", (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.contentDisposition)(opts.contentDisposition, opts.fileName));\n        xhr.addEventListener(\"load\", ()=>{\n            const etag = xhr.getResponseHeader(\"Etag\");\n            if (xhr.status >= 200 && xhr.status <= 299 && etag) {\n                return resume(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.succeed(etag));\n            }\n            return resume(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.fail(new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.RetryError()));\n        });\n        xhr.addEventListener(\"error\", ()=>resume(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.fail(new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.RetryError())));\n        let lastProgress = 0;\n        xhr.upload.addEventListener(\"progress\", (e)=>{\n            const delta = e.loaded - lastProgress;\n            lastProgress += delta;\n            opts.onProgress(delta);\n        });\n        xhr.send(opts.chunk);\n        // Cleanup function that runs on interruption\n        return effect_Micro__WEBPACK_IMPORTED_MODULE_1__.sync(()=>xhr.abort());\n    });\nconst uploadPresignedPostWithProgress = (file, presigned, opts)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.async((resume)=>{\n        const xhr = new XMLHttpRequest();\n        xhr.open(\"POST\", presigned.url);\n        xhr.setRequestHeader(\"Accept\", \"application/xml\");\n        xhr.upload.addEventListener(\"progress\", ({ loaded, total })=>{\n            opts.onUploadProgress?.({\n                file: file.name,\n                progress: loaded / total * 100\n            });\n        });\n        xhr.addEventListener(\"load\", ()=>resume(xhr.status >= 200 && xhr.status < 300 ? effect_Micro__WEBPACK_IMPORTED_MODULE_1__.succeed(null) : opts.reportEventToUT(\"failure\", {\n                fileKey: presigned.key,\n                uploadId: null,\n                fileName: file.name,\n                storageProviderError: xhr.responseText\n            })));\n        xhr.addEventListener(\"error\", ()=>resume(opts.reportEventToUT(\"failure\", {\n                fileKey: presigned.key,\n                uploadId: null,\n                fileName: file.name\n            })));\n        const formData = new FormData();\n        Object.entries(presigned.fields).forEach(([k, v])=>formData.append(k, v));\n        formData.append(\"file\", file); // File data **MUST GO LAST**\n        xhr.send(formData);\n        return effect_Micro__WEBPACK_IMPORTED_MODULE_1__.sync(()=>{\n            xhr.abort();\n        });\n    });\nconst maybeParseResponseXML = (maybeXml)=>{\n    const codeMatch = maybeXml.match(/<Code>(.*?)<\\/Code>/s);\n    const messageMatch = maybeXml.match(/<Message>(.*?)<\\/Message>/s);\n    const code = codeMatch?.[1];\n    const message = messageMatch?.[1];\n    if (!code || !message) return null;\n    return {\n        code: s3CodeToUploadThingCode[code] ?? DEFAULT_ERROR_CODE,\n        message\n    };\n};\n/**\n * Map S3 error codes to UploadThing error codes\n *\n * This is a subset of the S3 error codes, based on what seemed most likely to\n * occur in uploadthing. For a full list of S3 error codes, see:\n * https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html\n */ const DEFAULT_ERROR_CODE = \"UPLOAD_FAILED\";\nconst s3CodeToUploadThingCode = {\n    AccessDenied: \"FORBIDDEN\",\n    EntityTooSmall: \"TOO_SMALL\",\n    EntityTooLarge: \"TOO_LARGE\",\n    ExpiredToken: \"FORBIDDEN\",\n    IncorrectNumberOfFilesInPostRequest: \"TOO_MANY_FILES\",\n    InternalError: \"INTERNAL_SERVER_ERROR\",\n    KeyTooLongError: \"KEY_TOO_LONG\",\n    MaxMessageLengthExceeded: \"TOO_LARGE\"\n};\nconst createAPIRequestUrl = (config)=>{\n    const url = new URL(config.url);\n    const queryParams = new URLSearchParams(url.search);\n    queryParams.set(\"actionType\", config.actionType);\n    queryParams.set(\"slug\", config.slug);\n    url.search = queryParams.toString();\n    return url;\n};\n/**\n * Creates a \"client\" for reporting events to the UploadThing server via the user's API endpoint.\n * Events are handled in \"./handler.ts starting at L112\"\n */ const createUTReporter = (cfg)=>(type, payload)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.gen(function*() {\n            const url = createAPIRequestUrl({\n                url: cfg.url,\n                slug: cfg.endpoint,\n                actionType: type\n            });\n            let headers = typeof cfg.headers === \"function\" ? cfg.headers() : cfg.headers;\n            if (headers instanceof Promise) {\n                headers = yield* effect_Micro__WEBPACK_IMPORTED_MODULE_1__.promise(()=>headers);\n            }\n            const response = yield* (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.fetchEff)(url, {\n                method: \"POST\",\n                body: JSON.stringify(payload),\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    \"x-uploadthing-package\": cfg.package,\n                    \"x-uploadthing-version\": version$1,\n                    ...headers\n                }\n            }).pipe(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.andThen(_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.parseResponseJson), /**\n         * We don't _need_ to validate the response here, just cast it for now.\n         * As of now, @effect/schema includes quite a few bytes we cut out by this...\n         * We have \"strong typing\" on the backend that ensures the shape should match.\n         */ effect_Micro__WEBPACK_IMPORTED_MODULE_1__.map(effect_Function__WEBPACK_IMPORTED_MODULE_3__.unsafeCoerce), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.catchTag(\"FetchError\", (e)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.fail(new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                    code: \"INTERNAL_CLIENT_ERROR\",\n                    message: `Failed to report event \"${type}\" to UploadThing server`,\n                    cause: e\n                }))), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.catchTag(\"BadRequestError\", (e)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.fail(new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                    code: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.getErrorTypeFromStatusCode)(e.status),\n                    message: e.getMessage(),\n                    cause: e.json\n                }))), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.catchTag(\"InvalidJson\", (e)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.fail(new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                    code: \"INTERNAL_CLIENT_ERROR\",\n                    message: \"Failed to parse response from UploadThing server\",\n                    cause: e\n                }))));\n            switch(type){\n                case \"failure\":\n                    {\n                        // why isn't this narrowed automatically?\n                        const p = payload;\n                        const parsed = maybeParseResponseXML(p.storageProviderError ?? \"\");\n                        if (parsed?.message) {\n                            return yield* new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                                code: parsed.code,\n                                message: parsed.message\n                            });\n                        } else {\n                            return yield* new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                                code: \"UPLOAD_FAILED\",\n                                message: `Failed to upload file ${p.fileName} to S3`,\n                                cause: p.storageProviderError\n                            });\n                        }\n                    }\n            }\n            return response;\n        });\nconst version = version$1;\n/**\n * Validate that a file is of a valid type given a route config\n * @public\n */ const isValidFileType = (file, routeConfig)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.runSync((0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.getTypeFromFileName)(file.name, (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.objectKeys)(routeConfig)).pipe(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.map((type)=>file.type.includes(type)), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.orElseSucceed(()=>false)));\n/**\n * Validate that a file is of a valid size given a route config\n * @public\n */ const isValidFileSize = (file, routeConfig)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.runSync((0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.getTypeFromFileName)(file.name, (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.objectKeys)(routeConfig)).pipe(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.flatMap((type)=>(0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.fileSizeToBytes)(routeConfig[type].maxFileSize)), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.map((maxFileSize)=>file.size <= maxFileSize), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.orElseSucceed(()=>false)));\n/**\n * Generate a typed uploader for a given FileRouter\n * @public\n */ const genUploader = (initOpts)=>{\n    return (endpoint, opts)=>uploadFilesInternal(endpoint, {\n            ...opts,\n            url: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.resolveMaybeUrlArg)(initOpts?.url),\n            package: initOpts.package,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            input: opts.input\n        }).pipe(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.provideService(_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.FetchContext, {\n            fetch: globalThis.fetch.bind(globalThis),\n            baseHeaders: {\n                \"x-uploadthing-version\": version$1,\n                \"x-uploadthing-api-key\": undefined,\n                \"x-uploadthing-fe-package\": initOpts.package,\n                \"x-uploadthing-be-adapter\": undefined\n            }\n        }), (e)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.runPromiseExit(e, opts.signal ? {\n                signal: opts.signal\n            } : {})).then((exit)=>{\n            if (exit._tag === \"Right\") {\n                return exit.right;\n            } else if (exit.left._tag === \"Interrupt\") {\n                throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadAbortedError();\n            }\n            throw effect_Micro__WEBPACK_IMPORTED_MODULE_1__.causeSquash(exit.left);\n        });\n};\nconst uploadFilesInternal = (endpoint, opts)=>{\n    // classic service right here\n    const reportEventToUT = createUTReporter({\n        endpoint: String(endpoint),\n        package: opts.package,\n        url: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.resolveMaybeUrlArg)(opts.url),\n        headers: opts.headers\n    });\n    return reportEventToUT(\"upload\", {\n        input: \"input\" in opts ? opts.input : null,\n        files: opts.files.map((f)=>({\n                name: f.name,\n                size: f.size,\n                type: f.type\n            }))\n    }).pipe(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.flatMap((responses)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.forEach(responses, (presigned)=>uploadFile(String(endpoint), {\n                ...opts,\n                reportEventToUT\n            }, presigned).pipe(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.onInterrupt(reportEventToUT(\"failure\", {\n                fileKey: presigned.key,\n                uploadId: \"uploadId\" in presigned ? presigned.uploadId : null,\n                fileName: presigned.fileName\n            }).pipe(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.ignore))), {\n            concurrency: 6\n        })));\n};\nconst isPollingResponse = (input)=>{\n    if (!(0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(input)) return false;\n    if (input.status === \"done\") return \"callbackData\" in input;\n    return input.status === \"still waiting\";\n};\nconst isPollingDone = (input)=>{\n    return input.status === \"done\";\n};\nconst uploadFile = (slug, opts, presigned)=>effect_Array__WEBPACK_IMPORTED_MODULE_4__.findFirst(opts.files, (file)=>file.name === presigned.fileName).pipe(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.fromOption, effect_Micro__WEBPACK_IMPORTED_MODULE_1__.mapError(()=>{\n        // eslint-disable-next-line no-console\n        console.error(\"No file found for presigned URL\", presigned);\n        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n            code: \"NOT_FOUND\",\n            message: \"No file found for presigned URL\",\n            cause: `Expected file with name ${presigned.fileName} but got '${opts.files.join(\",\")}'`\n        });\n    }), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.tap((file)=>opts.onUploadBegin?.({\n            file: file.name\n        })), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.tap((file)=>\"urls\" in presigned ? uploadMultipartWithProgress(file, presigned, opts) : uploadPresignedPostWithProgress(file, presigned, opts)), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.zip((0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.fetchEff)(presigned.pollingUrl, {\n        headers: {\n            authorization: presigned.pollingJwt\n        }\n    }).pipe(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.flatMap(_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.parseResponseJson), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.catchTag(\"BadRequestError\", (e)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.fail(new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n            code: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.getErrorTypeFromStatusCode)(e.status),\n            message: e.message,\n            cause: e\n        }))), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.filterOrFailCause(isPollingResponse, (_)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.causeDie(\"received a non PollingResponse from the polling endpoint\")), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.filterOrFail(isPollingDone, ()=>new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.RetryError()), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.map(({ callbackData })=>callbackData), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.retry({\n        while: (res)=>res._tag === \"RetryError\",\n        schedule: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.exponentialDelay)()\n    }), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.when(()=>!opts.skipPolling), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.map(effect_Option__WEBPACK_IMPORTED_MODULE_5__.getOrNull), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.map(effect_Function__WEBPACK_IMPORTED_MODULE_3__.unsafeCoerce))), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.map(([file, serverData])=>({\n            name: file.name,\n            size: file.size,\n            key: presigned.key,\n            serverData,\n            url: presigned.fileUrl,\n            appUrl: presigned.appUrl,\n            customId: presigned.customId,\n            type: file.type\n        })));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXBsb2FkdGhpbmcvY2xpZW50L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9DO0FBQ1c7QUFDVDtBQUNFO0FBQzRPO0FBQzlJO0FBQ3JHO0FBRWpDLElBQUlzQixZQUFZO0FBRWhCLE1BQU1DLDhCQUE4QixDQUFDQyxNQUFNQyxXQUFXQyxPQUFPeEIsNkNBQVMsQ0FBQztRQUMvRCxJQUFJMEIsZ0JBQWdCO1FBQ3BCLE1BQU1DLFFBQVEsT0FBTzNCLGlEQUFhLENBQUN1QixVQUFVTSxJQUFJLEVBQUUsQ0FBQ0MsS0FBS0M7WUFDckQsTUFBTUMsU0FBU1QsVUFBVVUsU0FBUyxHQUFHRjtZQUNyQyxNQUFNRyxNQUFNQyxLQUFLQyxHQUFHLENBQUNKLFNBQVNULFVBQVVVLFNBQVMsRUFBRVgsS0FBS2UsSUFBSTtZQUM1RCxNQUFNQyxRQUFRaEIsS0FBS2lCLEtBQUssQ0FBQ1AsUUFBUUU7WUFDakMsT0FBT00sV0FBVztnQkFDZFY7Z0JBQ0FRLE9BQU9BO2dCQUNQbEMsb0JBQW9CbUIsVUFBVW5CLGtCQUFrQjtnQkFDaERxQyxVQUFVbkIsS0FBS29CLElBQUk7Z0JBQ25CQyxVQUFVckIsS0FBS3NCLElBQUk7Z0JBQ25CQyxZQUFZLENBQUNDO29CQUNUcEIsaUJBQWlCb0I7b0JBQ2pCLE1BQU1DLFVBQVVyQixnQkFBZ0JKLEtBQUtlLElBQUksR0FBRztvQkFDNUNiLEtBQUt3QixnQkFBZ0IsR0FBRzt3QkFDcEIxQixNQUFNQSxLQUFLc0IsSUFBSTt3QkFDZkssVUFBVUY7b0JBQ2Q7Z0JBQ0o7WUFDSixHQUFHRyxJQUFJLENBQUNsRCw2Q0FBUyxDQUFDLENBQUNvRCxNQUFPO29CQUNsQkE7b0JBQ0FDLFlBQVl0QixRQUFRO2dCQUN4QixLQUFLL0IsK0NBQVcsQ0FBQztnQkFDakJ1RCxPQUFPLENBQUNDLFFBQVFBLGlCQUFpQnRELDJEQUFVQTtnQkFDM0N1RCxPQUFPdEMsMkNBQU1BLEdBQUcsSUFBSTtn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YyxJQUFJL0wsa0RBQWMsQ0FBQyw4REFBOERBLHNEQUFrQixDQUFDa0wsZUFBZSxJQUFJLElBQUloTCwyREFBVUEsS0FBS0YsNkNBQVMsQ0FBQyxDQUFDLEVBQUVrTSxZQUFZLEVBQUUsR0FBR0EsZUFBZWxNLCtDQUFXLENBQUM7UUFDclB1RCxPQUFPLENBQUM0SSxNQUFNQSxJQUFJNUIsSUFBSSxLQUFLO1FBQzNCN0csVUFBVXZELHFFQUFnQkE7SUFDOUIsSUFBSUgsOENBQVUsQ0FBQyxJQUFJLENBQUN3QixLQUFLNkssV0FBVyxHQUFHck0sNkNBQVMsQ0FBQ0Msb0RBQWdCLEdBQUdELDZDQUFTLENBQUNELHlEQUFZQSxLQUFLQyw2Q0FBUyxDQUFDLENBQUMsQ0FBQ3NCLE1BQU1pTCxXQUFXLEdBQUk7WUFDeEgzSixNQUFNdEIsS0FBS3NCLElBQUk7WUFDZlAsTUFBTWYsS0FBS2UsSUFBSTtZQUNmMEIsS0FBS3hDLFVBQVV3QyxHQUFHO1lBQ2xCd0k7WUFDQXpLLEtBQUtQLFVBQVVpTCxPQUFPO1lBQ3RCQyxRQUFRbEwsVUFBVWtMLE1BQU07WUFDeEJDLFVBQVVuTCxVQUFVbUwsUUFBUTtZQUM1QmhLLE1BQU1wQixLQUFLb0IsSUFBSTtRQUNuQjtBQUUwRCIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50bHkvLi9ub2RlX21vZHVsZXMvdXBsb2FkdGhpbmcvY2xpZW50L2luZGV4LmpzPzZmNDMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQXJyIGZyb20gJ2VmZmVjdC9BcnJheSc7XG5pbXBvcnQgeyB1bnNhZmVDb2VyY2UgfSBmcm9tICdlZmZlY3QvRnVuY3Rpb24nO1xuaW1wb3J0ICogYXMgTWljcm8gZnJvbSAnZWZmZWN0L01pY3JvJztcbmltcG9ydCAqIGFzIE9wdGlvbiBmcm9tICdlZmZlY3QvT3B0aW9uJztcbmltcG9ydCB7IFJldHJ5RXJyb3IsIGV4cG9uZW50aWFsRGVsYXksIGNvbnRlbnREaXNwb3NpdGlvbiwgZmV0Y2hFZmYsIHBhcnNlUmVzcG9uc2VKc29uLCBVcGxvYWRUaGluZ0Vycm9yLCBnZXRFcnJvclR5cGVGcm9tU3RhdHVzQ29kZSwgZ2V0VHlwZUZyb21GaWxlTmFtZSwgb2JqZWN0S2V5cywgZmlsZVNpemVUb0J5dGVzLCByZXNvbHZlTWF5YmVVcmxBcmcsIEZldGNoQ29udGV4dCwgVXBsb2FkQWJvcnRlZEVycm9yLCBpc09iamVjdCB9IGZyb20gJ0B1cGxvYWR0aGluZy9zaGFyZWQnO1xuZXhwb3J0IHsgVXBsb2FkQWJvcnRlZEVycm9yLCBnZW5lcmF0ZUNsaWVudERyb3B6b25lQWNjZXB0LCBnZW5lcmF0ZU1pbWVUeXBlcywgZ2VuZXJhdGVQZXJtaXR0ZWRGaWxlVHlwZXMgfSBmcm9tICdAdXBsb2FkdGhpbmcvc2hhcmVkJztcbmltcG9ydCB7IGlzVGVzdCB9IGZyb20gJ3N0ZC1lbnYnO1xuXG52YXIgdmVyc2lvbiQxID0gXCI2LjEzLjNcIjtcblxuY29uc3QgdXBsb2FkTXVsdGlwYXJ0V2l0aFByb2dyZXNzID0gKGZpbGUsIHByZXNpZ25lZCwgb3B0cyk9Pk1pY3JvLmdlbihmdW5jdGlvbiooKSB7XG4gICAgICAgIGxldCB1cGxvYWRlZEJ5dGVzID0gMDtcbiAgICAgICAgY29uc3QgZXRhZ3MgPSB5aWVsZCogTWljcm8uZm9yRWFjaChwcmVzaWduZWQudXJscywgKHVybCwgaW5kZXgpPT57XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBwcmVzaWduZWQuY2h1bmtTaXplICogaW5kZXg7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihvZmZzZXQgKyBwcmVzaWduZWQuY2h1bmtTaXplLCBmaWxlLnNpemUpO1xuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBmaWxlLnNsaWNlKG9mZnNldCwgZW5kKTtcbiAgICAgICAgICAgIHJldHVybiB1cGxvYWRQYXJ0KHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgY2h1bms6IGNodW5rLFxuICAgICAgICAgICAgICAgIGNvbnRlbnREaXNwb3NpdGlvbjogcHJlc2lnbmVkLmNvbnRlbnREaXNwb3NpdGlvbixcbiAgICAgICAgICAgICAgICBmaWxlVHlwZTogZmlsZS50eXBlLFxuICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBmaWxlLm5hbWUsXG4gICAgICAgICAgICAgICAgb25Qcm9ncmVzczogKGRlbHRhKT0+e1xuICAgICAgICAgICAgICAgICAgICB1cGxvYWRlZEJ5dGVzICs9IGRlbHRhO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwZXJjZW50ID0gdXBsb2FkZWRCeXRlcyAvIGZpbGUuc2l6ZSAqIDEwMDtcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5vblVwbG9hZFByb2dyZXNzPy4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZTogZmlsZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IHBlcmNlbnRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkucGlwZShNaWNyby5tYXAoKHRhZyk9Pih7XG4gICAgICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgICAgICAgICAgcGFydE51bWJlcjogaW5kZXggKyAxXG4gICAgICAgICAgICAgICAgfSkpLCBNaWNyby5yZXRyeSh7XG4gICAgICAgICAgICAgICAgd2hpbGU6IChlcnJvcik9PmVycm9yIGluc3RhbmNlb2YgUmV0cnlFcnJvcixcbiAgICAgICAgICAgICAgICB0aW1lczogaXNUZXN0ID8gMyA6IDEwLFxuICAgICAgICAgICAgICAgIHNjaGVkdWxlOiBleHBvbmVudGlhbERlbGF5KClcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgY29uY3VycmVuY3k6IFwiaW5oZXJpdFwiXG4gICAgICAgIH0pLnBpcGUoTWljcm8udGFwRXJyb3IoKGVycm9yKT0+b3B0cy5yZXBvcnRFdmVudFRvVVQoXCJmYWlsdXJlXCIsIHtcbiAgICAgICAgICAgICAgICBmaWxlS2V5OiBwcmVzaWduZWQua2V5LFxuICAgICAgICAgICAgICAgIHVwbG9hZElkOiBwcmVzaWduZWQudXBsb2FkSWQsXG4gICAgICAgICAgICAgICAgZmlsZU5hbWU6IGZpbGUubmFtZSxcbiAgICAgICAgICAgICAgICBzdG9yYWdlUHJvdmlkZXJFcnJvcjogU3RyaW5nKGVycm9yKVxuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgLy8gVGVsbCB0aGUgc2VydmVyIHRoYXQgdGhlIHVwbG9hZCBpcyBjb21wbGV0ZVxuICAgICAgICB5aWVsZCogb3B0cy5yZXBvcnRFdmVudFRvVVQoXCJtdWx0aXBhcnQtY29tcGxldGVcIiwge1xuICAgICAgICAgICAgdXBsb2FkSWQ6IHByZXNpZ25lZC51cGxvYWRJZCxcbiAgICAgICAgICAgIGZpbGVLZXk6IHByZXNpZ25lZC5rZXksXG4gICAgICAgICAgICBldGFnc1xuICAgICAgICB9KTtcbiAgICB9KTtcbmNvbnN0IHVwbG9hZFBhcnQgPSAob3B0cyk9Pk1pY3JvLmFzeW5jKChyZXN1bWUpPT57XG4gICAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4aHIub3BlbihcIlBVVFwiLCBvcHRzLnVybCwgdHJ1ZSk7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsIG9wdHMuZmlsZVR5cGUpO1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtRGlzcG9zaXRpb25cIiwgY29udGVudERpc3Bvc2l0aW9uKG9wdHMuY29udGVudERpc3Bvc2l0aW9uLCBvcHRzLmZpbGVOYW1lKSk7XG4gICAgICAgIHhoci5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKT0+e1xuICAgICAgICAgICAgY29uc3QgZXRhZyA9IHhoci5nZXRSZXNwb25zZUhlYWRlcihcIkV0YWdcIik7XG4gICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8PSAyOTkgJiYgZXRhZykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bWUoTWljcm8uc3VjY2VlZChldGFnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdW1lKE1pY3JvLmZhaWwobmV3IFJldHJ5RXJyb3IoKSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoKT0+cmVzdW1lKE1pY3JvLmZhaWwobmV3IFJldHJ5RXJyb3IoKSkpKTtcbiAgICAgICAgbGV0IGxhc3RQcm9ncmVzcyA9IDA7XG4gICAgICAgIHhoci51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIsIChlKT0+e1xuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBlLmxvYWRlZCAtIGxhc3RQcm9ncmVzcztcbiAgICAgICAgICAgIGxhc3RQcm9ncmVzcyArPSBkZWx0YTtcbiAgICAgICAgICAgIG9wdHMub25Qcm9ncmVzcyhkZWx0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICB4aHIuc2VuZChvcHRzLmNodW5rKTtcbiAgICAgICAgLy8gQ2xlYW51cCBmdW5jdGlvbiB0aGF0IHJ1bnMgb24gaW50ZXJydXB0aW9uXG4gICAgICAgIHJldHVybiBNaWNyby5zeW5jKCgpPT54aHIuYWJvcnQoKSk7XG4gICAgfSk7XG5cbmNvbnN0IHVwbG9hZFByZXNpZ25lZFBvc3RXaXRoUHJvZ3Jlc3MgPSAoZmlsZSwgcHJlc2lnbmVkLCBvcHRzKT0+TWljcm8uYXN5bmMoKHJlc3VtZSk9PntcbiAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHhoci5vcGVuKFwiUE9TVFwiLCBwcmVzaWduZWQudXJsKTtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHRcIiwgXCJhcHBsaWNhdGlvbi94bWxcIik7XG4gICAgICAgIHhoci51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIsICh7IGxvYWRlZCwgdG90YWwgfSk9PntcbiAgICAgICAgICAgIG9wdHMub25VcGxvYWRQcm9ncmVzcz8uKHtcbiAgICAgICAgICAgICAgICBmaWxlOiBmaWxlLm5hbWUsXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IGxvYWRlZCAvIHRvdGFsICogMTAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHhoci5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKT0+cmVzdW1lKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDAgPyBNaWNyby5zdWNjZWVkKG51bGwpIDogb3B0cy5yZXBvcnRFdmVudFRvVVQoXCJmYWlsdXJlXCIsIHtcbiAgICAgICAgICAgICAgICBmaWxlS2V5OiBwcmVzaWduZWQua2V5LFxuICAgICAgICAgICAgICAgIHVwbG9hZElkOiBudWxsLFxuICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBmaWxlLm5hbWUsXG4gICAgICAgICAgICAgICAgc3RvcmFnZVByb3ZpZGVyRXJyb3I6IHhoci5yZXNwb25zZVRleHRcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgIHhoci5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKCk9PnJlc3VtZShvcHRzLnJlcG9ydEV2ZW50VG9VVChcImZhaWx1cmVcIiwge1xuICAgICAgICAgICAgICAgIGZpbGVLZXk6IHByZXNpZ25lZC5rZXksXG4gICAgICAgICAgICAgICAgdXBsb2FkSWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgZmlsZU5hbWU6IGZpbGUubmFtZVxuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMocHJlc2lnbmVkLmZpZWxkcykuZm9yRWFjaCgoW2ssIHZdKT0+Zm9ybURhdGEuYXBwZW5kKGssIHYpKTtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZVwiLCBmaWxlKTsgLy8gRmlsZSBkYXRhICoqTVVTVCBHTyBMQVNUKipcbiAgICAgICAgeGhyLnNlbmQoZm9ybURhdGEpO1xuICAgICAgICByZXR1cm4gTWljcm8uc3luYygoKT0+e1xuICAgICAgICAgICAgeGhyLmFib3J0KCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG5jb25zdCBtYXliZVBhcnNlUmVzcG9uc2VYTUwgPSAobWF5YmVYbWwpPT57XG4gICAgY29uc3QgY29kZU1hdGNoID0gbWF5YmVYbWwubWF0Y2goLzxDb2RlPiguKj8pPFxcL0NvZGU+L3MpO1xuICAgIGNvbnN0IG1lc3NhZ2VNYXRjaCA9IG1heWJlWG1sLm1hdGNoKC88TWVzc2FnZT4oLio/KTxcXC9NZXNzYWdlPi9zKTtcbiAgICBjb25zdCBjb2RlID0gY29kZU1hdGNoPy5bMV07XG4gICAgY29uc3QgbWVzc2FnZSA9IG1lc3NhZ2VNYXRjaD8uWzFdO1xuICAgIGlmICghY29kZSB8fCAhbWVzc2FnZSkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogczNDb2RlVG9VcGxvYWRUaGluZ0NvZGVbY29kZV0gPz8gREVGQVVMVF9FUlJPUl9DT0RFLFxuICAgICAgICBtZXNzYWdlXG4gICAgfTtcbn07XG4vKipcbiAqIE1hcCBTMyBlcnJvciBjb2RlcyB0byBVcGxvYWRUaGluZyBlcnJvciBjb2Rlc1xuICpcbiAqIFRoaXMgaXMgYSBzdWJzZXQgb2YgdGhlIFMzIGVycm9yIGNvZGVzLCBiYXNlZCBvbiB3aGF0IHNlZW1lZCBtb3N0IGxpa2VseSB0b1xuICogb2NjdXIgaW4gdXBsb2FkdGhpbmcuIEZvciBhIGZ1bGwgbGlzdCBvZiBTMyBlcnJvciBjb2Rlcywgc2VlOlxuICogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FtYXpvblMzL2xhdGVzdC9BUEkvRXJyb3JSZXNwb25zZXMuaHRtbFxuICovIGNvbnN0IERFRkFVTFRfRVJST1JfQ09ERSA9IFwiVVBMT0FEX0ZBSUxFRFwiO1xuY29uc3QgczNDb2RlVG9VcGxvYWRUaGluZ0NvZGUgPSB7XG4gICAgQWNjZXNzRGVuaWVkOiBcIkZPUkJJRERFTlwiLFxuICAgIEVudGl0eVRvb1NtYWxsOiBcIlRPT19TTUFMTFwiLFxuICAgIEVudGl0eVRvb0xhcmdlOiBcIlRPT19MQVJHRVwiLFxuICAgIEV4cGlyZWRUb2tlbjogXCJGT1JCSURERU5cIixcbiAgICBJbmNvcnJlY3ROdW1iZXJPZkZpbGVzSW5Qb3N0UmVxdWVzdDogXCJUT09fTUFOWV9GSUxFU1wiLFxuICAgIEludGVybmFsRXJyb3I6IFwiSU5URVJOQUxfU0VSVkVSX0VSUk9SXCIsXG4gICAgS2V5VG9vTG9uZ0Vycm9yOiBcIktFWV9UT09fTE9OR1wiLFxuICAgIE1heE1lc3NhZ2VMZW5ndGhFeGNlZWRlZDogXCJUT09fTEFSR0VcIlxufTtcblxuY29uc3QgY3JlYXRlQVBJUmVxdWVzdFVybCA9IChjb25maWcpPT57XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChjb25maWcudXJsKTtcbiAgICBjb25zdCBxdWVyeVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXModXJsLnNlYXJjaCk7XG4gICAgcXVlcnlQYXJhbXMuc2V0KFwiYWN0aW9uVHlwZVwiLCBjb25maWcuYWN0aW9uVHlwZSk7XG4gICAgcXVlcnlQYXJhbXMuc2V0KFwic2x1Z1wiLCBjb25maWcuc2x1Zyk7XG4gICAgdXJsLnNlYXJjaCA9IHF1ZXJ5UGFyYW1zLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIHVybDtcbn07XG4vKipcbiAqIENyZWF0ZXMgYSBcImNsaWVudFwiIGZvciByZXBvcnRpbmcgZXZlbnRzIHRvIHRoZSBVcGxvYWRUaGluZyBzZXJ2ZXIgdmlhIHRoZSB1c2VyJ3MgQVBJIGVuZHBvaW50LlxuICogRXZlbnRzIGFyZSBoYW5kbGVkIGluIFwiLi9oYW5kbGVyLnRzIHN0YXJ0aW5nIGF0IEwxMTJcIlxuICovIGNvbnN0IGNyZWF0ZVVUUmVwb3J0ZXIgPSAoY2ZnKT0+KHR5cGUsIHBheWxvYWQpPT5NaWNyby5nZW4oZnVuY3Rpb24qKCkge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gY3JlYXRlQVBJUmVxdWVzdFVybCh7XG4gICAgICAgICAgICAgICAgdXJsOiBjZmcudXJsLFxuICAgICAgICAgICAgICAgIHNsdWc6IGNmZy5lbmRwb2ludCxcbiAgICAgICAgICAgICAgICBhY3Rpb25UeXBlOiB0eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzID0gdHlwZW9mIGNmZy5oZWFkZXJzID09PSBcImZ1bmN0aW9uXCIgPyBjZmcuaGVhZGVycygpIDogY2ZnLmhlYWRlcnM7XG4gICAgICAgICAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzID0geWllbGQqIE1pY3JvLnByb21pc2UoKCk9PmhlYWRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCogZmV0Y2hFZmYodXJsLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgICAgICBcIngtdXBsb2FkdGhpbmctcGFja2FnZVwiOiBjZmcucGFja2FnZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ4LXVwbG9hZHRoaW5nLXZlcnNpb25cIjogdmVyc2lvbiQxLFxuICAgICAgICAgICAgICAgICAgICAuLi5oZWFkZXJzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkucGlwZShNaWNyby5hbmRUaGVuKHBhcnNlUmVzcG9uc2VKc29uKSwgLyoqXG4gICAgICAgICAqIFdlIGRvbid0IF9uZWVkXyB0byB2YWxpZGF0ZSB0aGUgcmVzcG9uc2UgaGVyZSwganVzdCBjYXN0IGl0IGZvciBub3cuXG4gICAgICAgICAqIEFzIG9mIG5vdywgQGVmZmVjdC9zY2hlbWEgaW5jbHVkZXMgcXVpdGUgYSBmZXcgYnl0ZXMgd2UgY3V0IG91dCBieSB0aGlzLi4uXG4gICAgICAgICAqIFdlIGhhdmUgXCJzdHJvbmcgdHlwaW5nXCIgb24gdGhlIGJhY2tlbmQgdGhhdCBlbnN1cmVzIHRoZSBzaGFwZSBzaG91bGQgbWF0Y2guXG4gICAgICAgICAqLyBNaWNyby5tYXAodW5zYWZlQ29lcmNlKSwgTWljcm8uY2F0Y2hUYWcoXCJGZXRjaEVycm9yXCIsIChlKT0+TWljcm8uZmFpbChuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiSU5URVJOQUxfQ0xJRU5UX0VSUk9SXCIsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBGYWlsZWQgdG8gcmVwb3J0IGV2ZW50IFwiJHt0eXBlfVwiIHRvIFVwbG9hZFRoaW5nIHNlcnZlcmAsXG4gICAgICAgICAgICAgICAgICAgIGNhdXNlOiBlXG4gICAgICAgICAgICAgICAgfSkpKSwgTWljcm8uY2F0Y2hUYWcoXCJCYWRSZXF1ZXN0RXJyb3JcIiwgKGUpPT5NaWNyby5mYWlsKG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogZ2V0RXJyb3JUeXBlRnJvbVN0YXR1c0NvZGUoZS5zdGF0dXMpLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlLmdldE1lc3NhZ2UoKSxcbiAgICAgICAgICAgICAgICAgICAgY2F1c2U6IGUuanNvblxuICAgICAgICAgICAgICAgIH0pKSksIE1pY3JvLmNhdGNoVGFnKFwiSW52YWxpZEpzb25cIiwgKGUpPT5NaWNyby5mYWlsKG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogXCJJTlRFUk5BTF9DTElFTlRfRVJST1JcIixcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJGYWlsZWQgdG8gcGFyc2UgcmVzcG9uc2UgZnJvbSBVcGxvYWRUaGluZyBzZXJ2ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgY2F1c2U6IGVcbiAgICAgICAgICAgICAgICB9KSkpKTtcbiAgICAgICAgICAgIHN3aXRjaCh0eXBlKXtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFpbHVyZVwiOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aHkgaXNuJ3QgdGhpcyBuYXJyb3dlZCBhdXRvbWF0aWNhbGx5P1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IHBheWxvYWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBtYXliZVBhcnNlUmVzcG9uc2VYTUwocC5zdG9yYWdlUHJvdmlkZXJFcnJvciA/PyBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWQ/Lm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogcGFyc2VkLmNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHBhcnNlZC5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlVQTE9BRF9GQUlMRURcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYEZhaWxlZCB0byB1cGxvYWQgZmlsZSAke3AuZmlsZU5hbWV9IHRvIFMzYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F1c2U6IHAuc3RvcmFnZVByb3ZpZGVyRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9KTtcblxuY29uc3QgdmVyc2lvbiA9IHZlcnNpb24kMTtcbi8qKlxuICogVmFsaWRhdGUgdGhhdCBhIGZpbGUgaXMgb2YgYSB2YWxpZCB0eXBlIGdpdmVuIGEgcm91dGUgY29uZmlnXG4gKiBAcHVibGljXG4gKi8gY29uc3QgaXNWYWxpZEZpbGVUeXBlID0gKGZpbGUsIHJvdXRlQ29uZmlnKT0+TWljcm8ucnVuU3luYyhnZXRUeXBlRnJvbUZpbGVOYW1lKGZpbGUubmFtZSwgb2JqZWN0S2V5cyhyb3V0ZUNvbmZpZykpLnBpcGUoTWljcm8ubWFwKCh0eXBlKT0+ZmlsZS50eXBlLmluY2x1ZGVzKHR5cGUpKSwgTWljcm8ub3JFbHNlU3VjY2VlZCgoKT0+ZmFsc2UpKSk7XG4vKipcbiAqIFZhbGlkYXRlIHRoYXQgYSBmaWxlIGlzIG9mIGEgdmFsaWQgc2l6ZSBnaXZlbiBhIHJvdXRlIGNvbmZpZ1xuICogQHB1YmxpY1xuICovIGNvbnN0IGlzVmFsaWRGaWxlU2l6ZSA9IChmaWxlLCByb3V0ZUNvbmZpZyk9Pk1pY3JvLnJ1blN5bmMoZ2V0VHlwZUZyb21GaWxlTmFtZShmaWxlLm5hbWUsIG9iamVjdEtleXMocm91dGVDb25maWcpKS5waXBlKE1pY3JvLmZsYXRNYXAoKHR5cGUpPT5maWxlU2l6ZVRvQnl0ZXMocm91dGVDb25maWdbdHlwZV0ubWF4RmlsZVNpemUpKSwgTWljcm8ubWFwKChtYXhGaWxlU2l6ZSk9PmZpbGUuc2l6ZSA8PSBtYXhGaWxlU2l6ZSksIE1pY3JvLm9yRWxzZVN1Y2NlZWQoKCk9PmZhbHNlKSkpO1xuLyoqXG4gKiBHZW5lcmF0ZSBhIHR5cGVkIHVwbG9hZGVyIGZvciBhIGdpdmVuIEZpbGVSb3V0ZXJcbiAqIEBwdWJsaWNcbiAqLyBjb25zdCBnZW5VcGxvYWRlciA9IChpbml0T3B0cyk9PntcbiAgICByZXR1cm4gKGVuZHBvaW50LCBvcHRzKT0+dXBsb2FkRmlsZXNJbnRlcm5hbChlbmRwb2ludCwge1xuICAgICAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgICAgIHVybDogcmVzb2x2ZU1heWJlVXJsQXJnKGluaXRPcHRzPy51cmwpLFxuICAgICAgICAgICAgcGFja2FnZTogaW5pdE9wdHMucGFja2FnZSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgIGlucHV0OiBvcHRzLmlucHV0XG4gICAgICAgIH0pLnBpcGUoTWljcm8ucHJvdmlkZVNlcnZpY2UoRmV0Y2hDb250ZXh0LCB7XG4gICAgICAgICAgICBmZXRjaDogZ2xvYmFsVGhpcy5mZXRjaC5iaW5kKGdsb2JhbFRoaXMpLFxuICAgICAgICAgICAgYmFzZUhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIngtdXBsb2FkdGhpbmctdmVyc2lvblwiOiB2ZXJzaW9uJDEsXG4gICAgICAgICAgICAgICAgXCJ4LXVwbG9hZHRoaW5nLWFwaS1rZXlcIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIFwieC11cGxvYWR0aGluZy1mZS1wYWNrYWdlXCI6IGluaXRPcHRzLnBhY2thZ2UsXG4gICAgICAgICAgICAgICAgXCJ4LXVwbG9hZHRoaW5nLWJlLWFkYXB0ZXJcIjogdW5kZWZpbmVkXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCAoZSk9Pk1pY3JvLnJ1blByb21pc2VFeGl0KGUsIG9wdHMuc2lnbmFsID8ge1xuICAgICAgICAgICAgICAgIHNpZ25hbDogb3B0cy5zaWduYWxcbiAgICAgICAgICAgIH0gOiB7fSkpLnRoZW4oKGV4aXQpPT57XG4gICAgICAgICAgICBpZiAoZXhpdC5fdGFnID09PSBcIlJpZ2h0XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhpdC5yaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhpdC5sZWZ0Ll90YWcgPT09IFwiSW50ZXJydXB0XCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXBsb2FkQWJvcnRlZEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBNaWNyby5jYXVzZVNxdWFzaChleGl0LmxlZnQpO1xuICAgICAgICB9KTtcbn07XG5jb25zdCB1cGxvYWRGaWxlc0ludGVybmFsID0gKGVuZHBvaW50LCBvcHRzKT0+e1xuICAgIC8vIGNsYXNzaWMgc2VydmljZSByaWdodCBoZXJlXG4gICAgY29uc3QgcmVwb3J0RXZlbnRUb1VUID0gY3JlYXRlVVRSZXBvcnRlcih7XG4gICAgICAgIGVuZHBvaW50OiBTdHJpbmcoZW5kcG9pbnQpLFxuICAgICAgICBwYWNrYWdlOiBvcHRzLnBhY2thZ2UsXG4gICAgICAgIHVybDogcmVzb2x2ZU1heWJlVXJsQXJnKG9wdHMudXJsKSxcbiAgICAgICAgaGVhZGVyczogb3B0cy5oZWFkZXJzXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcG9ydEV2ZW50VG9VVChcInVwbG9hZFwiLCB7XG4gICAgICAgIGlucHV0OiBcImlucHV0XCIgaW4gb3B0cyA/IG9wdHMuaW5wdXQgOiBudWxsLFxuICAgICAgICBmaWxlczogb3B0cy5maWxlcy5tYXAoKGYpPT4oe1xuICAgICAgICAgICAgICAgIG5hbWU6IGYubmFtZSxcbiAgICAgICAgICAgICAgICBzaXplOiBmLnNpemUsXG4gICAgICAgICAgICAgICAgdHlwZTogZi50eXBlXG4gICAgICAgICAgICB9KSlcbiAgICB9KS5waXBlKE1pY3JvLmZsYXRNYXAoKHJlc3BvbnNlcyk9Pk1pY3JvLmZvckVhY2gocmVzcG9uc2VzLCAocHJlc2lnbmVkKT0+dXBsb2FkRmlsZShTdHJpbmcoZW5kcG9pbnQpLCB7XG4gICAgICAgICAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgICAgICAgICByZXBvcnRFdmVudFRvVVRcbiAgICAgICAgICAgIH0sIHByZXNpZ25lZCkucGlwZShNaWNyby5vbkludGVycnVwdChyZXBvcnRFdmVudFRvVVQoXCJmYWlsdXJlXCIsIHtcbiAgICAgICAgICAgICAgICBmaWxlS2V5OiBwcmVzaWduZWQua2V5LFxuICAgICAgICAgICAgICAgIHVwbG9hZElkOiBcInVwbG9hZElkXCIgaW4gcHJlc2lnbmVkID8gcHJlc2lnbmVkLnVwbG9hZElkIDogbnVsbCxcbiAgICAgICAgICAgICAgICBmaWxlTmFtZTogcHJlc2lnbmVkLmZpbGVOYW1lXG4gICAgICAgICAgICB9KS5waXBlKE1pY3JvLmlnbm9yZSkpKSwge1xuICAgICAgICAgICAgY29uY3VycmVuY3k6IDZcbiAgICAgICAgfSkpKTtcbn07XG5jb25zdCBpc1BvbGxpbmdSZXNwb25zZSA9IChpbnB1dCk9PntcbiAgICBpZiAoIWlzT2JqZWN0KGlucHV0KSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChpbnB1dC5zdGF0dXMgPT09IFwiZG9uZVwiKSByZXR1cm4gXCJjYWxsYmFja0RhdGFcIiBpbiBpbnB1dDtcbiAgICByZXR1cm4gaW5wdXQuc3RhdHVzID09PSBcInN0aWxsIHdhaXRpbmdcIjtcbn07XG5jb25zdCBpc1BvbGxpbmdEb25lID0gKGlucHV0KT0+e1xuICAgIHJldHVybiBpbnB1dC5zdGF0dXMgPT09IFwiZG9uZVwiO1xufTtcbmNvbnN0IHVwbG9hZEZpbGUgPSAoc2x1Zywgb3B0cywgcHJlc2lnbmVkKT0+QXJyLmZpbmRGaXJzdChvcHRzLmZpbGVzLCAoZmlsZSk9PmZpbGUubmFtZSA9PT0gcHJlc2lnbmVkLmZpbGVOYW1lKS5waXBlKE1pY3JvLmZyb21PcHRpb24sIE1pY3JvLm1hcEVycm9yKCgpPT57XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJObyBmaWxlIGZvdW5kIGZvciBwcmVzaWduZWQgVVJMXCIsIHByZXNpZ25lZCk7XG4gICAgICAgIHJldHVybiBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICBjb2RlOiBcIk5PVF9GT1VORFwiLFxuICAgICAgICAgICAgbWVzc2FnZTogXCJObyBmaWxlIGZvdW5kIGZvciBwcmVzaWduZWQgVVJMXCIsXG4gICAgICAgICAgICBjYXVzZTogYEV4cGVjdGVkIGZpbGUgd2l0aCBuYW1lICR7cHJlc2lnbmVkLmZpbGVOYW1lfSBidXQgZ290ICcke29wdHMuZmlsZXMuam9pbihcIixcIil9J2BcbiAgICAgICAgfSk7XG4gICAgfSksIE1pY3JvLnRhcCgoZmlsZSk9Pm9wdHMub25VcGxvYWRCZWdpbj8uKHtcbiAgICAgICAgICAgIGZpbGU6IGZpbGUubmFtZVxuICAgICAgICB9KSksIE1pY3JvLnRhcCgoZmlsZSk9PlwidXJsc1wiIGluIHByZXNpZ25lZCA/IHVwbG9hZE11bHRpcGFydFdpdGhQcm9ncmVzcyhmaWxlLCBwcmVzaWduZWQsIG9wdHMpIDogdXBsb2FkUHJlc2lnbmVkUG9zdFdpdGhQcm9ncmVzcyhmaWxlLCBwcmVzaWduZWQsIG9wdHMpKSwgTWljcm8uemlwKGZldGNoRWZmKHByZXNpZ25lZC5wb2xsaW5nVXJsLCB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIGF1dGhvcml6YXRpb246IHByZXNpZ25lZC5wb2xsaW5nSnd0XG4gICAgICAgIH1cbiAgICB9KS5waXBlKE1pY3JvLmZsYXRNYXAocGFyc2VSZXNwb25zZUpzb24pLCBNaWNyby5jYXRjaFRhZyhcIkJhZFJlcXVlc3RFcnJvclwiLCAoZSk9Pk1pY3JvLmZhaWwobmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgY29kZTogZ2V0RXJyb3JUeXBlRnJvbVN0YXR1c0NvZGUoZS5zdGF0dXMpLFxuICAgICAgICAgICAgbWVzc2FnZTogZS5tZXNzYWdlLFxuICAgICAgICAgICAgY2F1c2U6IGVcbiAgICAgICAgfSkpKSwgTWljcm8uZmlsdGVyT3JGYWlsQ2F1c2UoaXNQb2xsaW5nUmVzcG9uc2UsIChfKT0+TWljcm8uY2F1c2VEaWUoXCJyZWNlaXZlZCBhIG5vbiBQb2xsaW5nUmVzcG9uc2UgZnJvbSB0aGUgcG9sbGluZyBlbmRwb2ludFwiKSksIE1pY3JvLmZpbHRlck9yRmFpbChpc1BvbGxpbmdEb25lLCAoKT0+bmV3IFJldHJ5RXJyb3IoKSksIE1pY3JvLm1hcCgoeyBjYWxsYmFja0RhdGEgfSk9PmNhbGxiYWNrRGF0YSksIE1pY3JvLnJldHJ5KHtcbiAgICAgICAgd2hpbGU6IChyZXMpPT5yZXMuX3RhZyA9PT0gXCJSZXRyeUVycm9yXCIsXG4gICAgICAgIHNjaGVkdWxlOiBleHBvbmVudGlhbERlbGF5KClcbiAgICB9KSwgTWljcm8ud2hlbigoKT0+IW9wdHMuc2tpcFBvbGxpbmcpLCBNaWNyby5tYXAoT3B0aW9uLmdldE9yTnVsbCksIE1pY3JvLm1hcCh1bnNhZmVDb2VyY2UpKSksIE1pY3JvLm1hcCgoW2ZpbGUsIHNlcnZlckRhdGFdKT0+KHtcbiAgICAgICAgICAgIG5hbWU6IGZpbGUubmFtZSxcbiAgICAgICAgICAgIHNpemU6IGZpbGUuc2l6ZSxcbiAgICAgICAgICAgIGtleTogcHJlc2lnbmVkLmtleSxcbiAgICAgICAgICAgIHNlcnZlckRhdGEsXG4gICAgICAgICAgICB1cmw6IHByZXNpZ25lZC5maWxlVXJsLFxuICAgICAgICAgICAgYXBwVXJsOiBwcmVzaWduZWQuYXBwVXJsLFxuICAgICAgICAgICAgY3VzdG9tSWQ6IHByZXNpZ25lZC5jdXN0b21JZCxcbiAgICAgICAgICAgIHR5cGU6IGZpbGUudHlwZVxuICAgICAgICB9KSkpO1xuXG5leHBvcnQgeyBnZW5VcGxvYWRlciwgaXNWYWxpZEZpbGVTaXplLCBpc1ZhbGlkRmlsZVR5cGUsIHZlcnNpb24gfTtcbiJdLCJuYW1lcyI6WyJBcnIiLCJ1bnNhZmVDb2VyY2UiLCJNaWNybyIsIk9wdGlvbiIsIlJldHJ5RXJyb3IiLCJleHBvbmVudGlhbERlbGF5IiwiY29udGVudERpc3Bvc2l0aW9uIiwiZmV0Y2hFZmYiLCJwYXJzZVJlc3BvbnNlSnNvbiIsIlVwbG9hZFRoaW5nRXJyb3IiLCJnZXRFcnJvclR5cGVGcm9tU3RhdHVzQ29kZSIsImdldFR5cGVGcm9tRmlsZU5hbWUiLCJvYmplY3RLZXlzIiwiZmlsZVNpemVUb0J5dGVzIiwicmVzb2x2ZU1heWJlVXJsQXJnIiwiRmV0Y2hDb250ZXh0IiwiVXBsb2FkQWJvcnRlZEVycm9yIiwiaXNPYmplY3QiLCJnZW5lcmF0ZUNsaWVudERyb3B6b25lQWNjZXB0IiwiZ2VuZXJhdGVNaW1lVHlwZXMiLCJnZW5lcmF0ZVBlcm1pdHRlZEZpbGVUeXBlcyIsImlzVGVzdCIsInZlcnNpb24kMSIsInVwbG9hZE11bHRpcGFydFdpdGhQcm9ncmVzcyIsImZpbGUiLCJwcmVzaWduZWQiLCJvcHRzIiwiZ2VuIiwidXBsb2FkZWRCeXRlcyIsImV0YWdzIiwiZm9yRWFjaCIsInVybHMiLCJ1cmwiLCJpbmRleCIsIm9mZnNldCIsImNodW5rU2l6ZSIsImVuZCIsIk1hdGgiLCJtaW4iLCJzaXplIiwiY2h1bmsiLCJzbGljZSIsInVwbG9hZFBhcnQiLCJmaWxlVHlwZSIsInR5cGUiLCJmaWxlTmFtZSIsIm5hbWUiLCJvblByb2dyZXNzIiwiZGVsdGEiLCJwZXJjZW50Iiwib25VcGxvYWRQcm9ncmVzcyIsInByb2dyZXNzIiwicGlwZSIsIm1hcCIsInRhZyIsInBhcnROdW1iZXIiLCJyZXRyeSIsIndoaWxlIiwiZXJyb3IiLCJ0aW1lcyIsInNjaGVkdWxlIiwiY29uY3VycmVuY3kiLCJ0YXBFcnJvciIsInJlcG9ydEV2ZW50VG9VVCIsImZpbGVLZXkiLCJrZXkiLCJ1cGxvYWRJZCIsInN0b3JhZ2VQcm92aWRlckVycm9yIiwiU3RyaW5nIiwiYXN5bmMiLCJyZXN1bWUiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJzZXRSZXF1ZXN0SGVhZGVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV0YWciLCJnZXRSZXNwb25zZUhlYWRlciIsInN0YXR1cyIsInN1Y2NlZWQiLCJmYWlsIiwibGFzdFByb2dyZXNzIiwidXBsb2FkIiwiZSIsImxvYWRlZCIsInNlbmQiLCJzeW5jIiwiYWJvcnQiLCJ1cGxvYWRQcmVzaWduZWRQb3N0V2l0aFByb2dyZXNzIiwidG90YWwiLCJyZXNwb25zZVRleHQiLCJmb3JtRGF0YSIsIkZvcm1EYXRhIiwiT2JqZWN0IiwiZW50cmllcyIsImZpZWxkcyIsImsiLCJ2IiwiYXBwZW5kIiwibWF5YmVQYXJzZVJlc3BvbnNlWE1MIiwibWF5YmVYbWwiLCJjb2RlTWF0Y2giLCJtYXRjaCIsIm1lc3NhZ2VNYXRjaCIsImNvZGUiLCJtZXNzYWdlIiwiczNDb2RlVG9VcGxvYWRUaGluZ0NvZGUiLCJERUZBVUxUX0VSUk9SX0NPREUiLCJBY2Nlc3NEZW5pZWQiLCJFbnRpdHlUb29TbWFsbCIsIkVudGl0eVRvb0xhcmdlIiwiRXhwaXJlZFRva2VuIiwiSW5jb3JyZWN0TnVtYmVyT2ZGaWxlc0luUG9zdFJlcXVlc3QiLCJJbnRlcm5hbEVycm9yIiwiS2V5VG9vTG9uZ0Vycm9yIiwiTWF4TWVzc2FnZUxlbmd0aEV4Y2VlZGVkIiwiY3JlYXRlQVBJUmVxdWVzdFVybCIsImNvbmZpZyIsIlVSTCIsInF1ZXJ5UGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwic2VhcmNoIiwic2V0IiwiYWN0aW9uVHlwZSIsInNsdWciLCJ0b1N0cmluZyIsImNyZWF0ZVVUUmVwb3J0ZXIiLCJjZmciLCJwYXlsb2FkIiwiZW5kcG9pbnQiLCJoZWFkZXJzIiwiUHJvbWlzZSIsInByb21pc2UiLCJyZXNwb25zZSIsIm1ldGhvZCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwicGFja2FnZSIsImFuZFRoZW4iLCJjYXRjaFRhZyIsImNhdXNlIiwiZ2V0TWVzc2FnZSIsImpzb24iLCJwIiwicGFyc2VkIiwidmVyc2lvbiIsImlzVmFsaWRGaWxlVHlwZSIsInJvdXRlQ29uZmlnIiwicnVuU3luYyIsImluY2x1ZGVzIiwib3JFbHNlU3VjY2VlZCIsImlzVmFsaWRGaWxlU2l6ZSIsImZsYXRNYXAiLCJtYXhGaWxlU2l6ZSIsImdlblVwbG9hZGVyIiwiaW5pdE9wdHMiLCJ1cGxvYWRGaWxlc0ludGVybmFsIiwiaW5wdXQiLCJwcm92aWRlU2VydmljZSIsImZldGNoIiwiZ2xvYmFsVGhpcyIsImJpbmQiLCJiYXNlSGVhZGVycyIsInVuZGVmaW5lZCIsInJ1blByb21pc2VFeGl0Iiwic2lnbmFsIiwidGhlbiIsImV4aXQiLCJfdGFnIiwicmlnaHQiLCJsZWZ0IiwiY2F1c2VTcXVhc2giLCJmaWxlcyIsImYiLCJyZXNwb25zZXMiLCJ1cGxvYWRGaWxlIiwib25JbnRlcnJ1cHQiLCJpZ25vcmUiLCJpc1BvbGxpbmdSZXNwb25zZSIsImlzUG9sbGluZ0RvbmUiLCJmaW5kRmlyc3QiLCJmcm9tT3B0aW9uIiwibWFwRXJyb3IiLCJjb25zb2xlIiwiam9pbiIsInRhcCIsIm9uVXBsb2FkQmVnaW4iLCJ6aXAiLCJwb2xsaW5nVXJsIiwiYXV0aG9yaXphdGlvbiIsInBvbGxpbmdKd3QiLCJmaWx0ZXJPckZhaWxDYXVzZSIsIl8iLCJjYXVzZURpZSIsImZpbHRlck9yRmFpbCIsImNhbGxiYWNrRGF0YSIsInJlcyIsIndoZW4iLCJza2lwUG9sbGluZyIsImdldE9yTnVsbCIsInNlcnZlckRhdGEiLCJmaWxlVXJsIiwiYXBwVXJsIiwiY3VzdG9tSWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/uploadthing/client/index.js\n");

/***/ })

};
;